
## 유니런

### 컴퓨터 사양마다 frameRate가 다른데 매 프레임마다 실행되는 update()를 어떻게 처리해야 할까

update() 필드는 1프레임마다 실행되므로 물체를 60f만큼 회전하는 기능을 update()내에 구현한다면 1프레임마다 60f 만큼 회전함.

이를 해결하기 위해 회전값을 프레임의 역수로 나눠야 함 -> `60f \* Time.deltaTime.`

### Text UI를 만들었으나 GameManager 인스펙터에 아무 오브젝트도 뜨지 않음

> `timeText`와 `recordText`는 `Text` 타입으로 선언되어 있습니다. 만약 Unity UI Text가 아니라 TextMeshPro를 사용하는 경우라면 타입이 맞지 않아 문제가 생길 수 있습니다.

#### 해결 방법:

- 만약 TextMeshPro를 사용 중이라면, `using TMPro;`를 추가하고 `Text` 타입을 `TMP_Text`로 변경해야 합니다.

-> 기존에 선언한 변수의 타입은 Text 인데, TextMeshPro를 사용했으니 알맞은 변수 타입으로 선언해줬어야 했다. 

### 유한 상태 머신(FSM)

- 애니메이터 컨트롤러는 유한 상태 머신으로 재생할 애니메이션을 결정하는 에셋이다.
- 유한 상태머신은 유한한 개수의 상태 중 한 번에 하나만 현재 상태가 될 수 있지만, 상태와 상태 사이를 전이를 통해 이동할 수 있는 설계 모델이다.

### Has Exit time

`Animator - Inspector - Has Exit Time`

- 종료 시점을 활성화하는 옵션. 전이에서 핸재 상태를 탈출하여 다음 상태로 넘어가는 시점. 
- 이게 활성화되면 종료시점이 존재하게 되어 전이의 조건을만족해도 즉시 다음 상태로 전이하지 않는다. 즉, 현재 상태의 애니메이션 클립의 재생 시간이 종료 시점에 도달할 때까지 전이가 지연된다. 반대로 비활성화되면 전이 조건을 만족하는 즉시 전이가 실행된다.

### Transition Duration

`Animator - Inspector - Transition Duration

- `전환 지속시간`은 전이가 이루어지는 동안 현재 애니메이션 클립과 다음 애니메이션 클립을 섞어(블랜딩) 부드럽게 이어주는 역할을 한다.

- 0.2로 세팅되었을 때, 현재 동작과 다음 동작의 애니메이션 클립이 0.2초동안 섞여 부드럽게 이어진다.

- 하지만 2D 스프라이트를 사용한 애니메이션 클립에서는 전환 지속 시간 동안의 블렌딩이 정상적으로 동작하지 않고 전이 시점만 지연된다. -> 캐릭터의 관절이 존재하지 않기 때문. 따라서 3D 프로젝트에 주로 사용된다.

### collision.contacts[0].normal.y

~~~ cs
 private void OnCollisionEnter2D(Collision2D collision) {
      // 바닥에 닿았음을 감지하는 처리
      if (collision.contacts[0].normal.y > 0.7f)
      {
          isGrounded = true;
          jumpCount = 0;
      }
 }
~~~
- OnCollision 계열의 충돌 이벤트 메서드는 여러 충돌 정보를 담는 Collision 타입의 데이터를 입력받는다. Collision 타입은 충돌 지점들의 점보를 담는 ContactPoint 타입의 데이터를 contacts라는 배열 변수로 제공한다. 따라서 contacts 배열의 길이는 충돌 지점의 개수와 일치한다.

- collision.contacts[0]은 두 물체 사이의 여러 충돌 지점중에서 첫 번째 충돌 지점의 정보를 가져온 것이다.

#### **`normal.y > 0.7f`** 왜 굳이 0.7일까

- 평평한 바닥의 법선 벡터는 (0, 1)이고, 수직 벽의 법선 벡터는 (1, 0) 또는 (-1, 0)이다.
- `0.7`은 일반적으로 적당한 경사(약 45도 이하)까지 바닥으로 간주할 수 있는 타협점으로서 사용됨. 
- 즉 바닥의 기준을 완전 평평할 때만이 아닌 살짝의 경사가 있더라도 인정해주기 위해 0.7f라는 수치를 사용했다. 

### 싱글턴 패턴

#### 싱글턴 패턴을 사용하는 이유

- 게임 매니저 오브젝트는 단 하나만 존재.
- 어떤 곳에서도 손쉽게 게임 매니저 오브젝트에 접근 가능.

> 어떤 변수를 static으로 선언하면 여러 오브젝트가 해당 변수 하나를 공유한다. 정적 선언된 변수는 해당 타입의 오브젝트를 몇 개를 생성하든 그 수에 상관없이 메모리에 하나만 존재한다. 


### OnEnable()

- OnEnable() 메서드는 Awake()나 Start() 같은 유니티 이벤트 메서드다. Start() 메서드처럼 컴포넌트가 활성화될 때 자동으로 한 번 실행된다. 
- 하지만 처음 한 번만 실행되는 Start() 메서드와는 달리 OnEnable() 메서드는 컴포넌트가 활성화될 때마다 매번 다시 실행된다. 
- 따라서 OnEnable 메서드는 컴포넌트를 끄고 다시 켜는 방식으로 재 실행될 수 있다.

### 오브젝트 풀링

매번 새로운 오브젝트를 생성하면 오브젝트 수가 계속 늘어나기 때문에 메모리 사용량이 계속 증가한다. 
오브젝트 풀링 방식을 사용하면 이러한 문제를 해결 가능.

- 오브젝트 풀링이란 초기에 필요한 만큼 오브젝트를 미리 만들어 풀(웅덩이)에 쌓아두는 방식.
- 풀에 오브젝트를 생성해준 이후에는 새로운 오브젝트가 필요할 때 새로운 오브젝트를 생성하지 않고 풀에 있는 오브젝트를 가져다 쓴다. 오브젝트가 필요 없을 때는 오브젝트를 파괴하는 대신 오브젝트를 비활성화하고 풀에 반환한다.

예제에서는 보이지 않는 게임 화면 바깥에 오브젝트들을 미리 만드는 방식을 취하고 있음.


